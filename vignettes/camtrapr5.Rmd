---
title: "5. Multi-species occupancy models"
author: Juergen Niedballa (<camtrapr@gmail.com>)
date: "`r Sys.Date()`"
output:
    rmarkdown::html_vignette:
      toc: true
      toc_depth: 2
      toc_float: true
      df_print: kable
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{5. Multi-species occupancy models}
  %\VignetteDepends{raster}
  \usepackage[utf8]{inputenc}
---

```{r  results = "hide"}
library(camtrapR)
library(purrr)
library(DT)
library(knitr)
library(ggplot2)
```

# Overview

Multi-species occupancy models are a powerful group of models that combine information from many species to estimate individual species' responses as well as community-level responses to environmental variables. 

They are normally fit in Bayesian frameworks, e.g. BUGS, JAGS or Nimble. Creating the necessary input for these models from camera trapping data, writing the model code, setting parameters to monitor, initial values etc. can however be daunting, and even for seasoned users can be a tedious and time-consuming task. 

A new extension of camtrapR aims to simplify this process by automatically and flexibly creating custom community occupancy models that are ready for analysis in JAGS or Nimble. The workflow supports:

* continuous and categorical site covariates on detection and occupancy probability
* continuous and categorical observation-level covariates on detection probability
* fixed and random effects of all these covariates
* independent effects of continuous site covariates between the different species
* nested random effects
* fixed, independent or random intercepts of detection and occupancy probability
* data augmentation (fully open community or known maximum species richness)
* species richness estimates
* models in JAGS and Nimble
* derived quantities, e.g. Bayesian p-values (overall and by species) and species richness estimates

The main function is `communityModel()`. It automates:

* writing model code
* setting parameters to monitor
* setting initial values
* bundling input data

The output is a `commOccu` object. The workflow then provides methods for: 

* fitting models
* plotting marginal effects (response curves)
* plotting effect sizes
* spatial predictions of species occupancy probabilities
* spatial predictions of species richness

The output of fit() is an mcmc.list from the coda package and can be uses as such, so the summary(), plot(), etc. methods are available as well as the functions from bayesplot.

The main function `communityModel` does not support R formula syntax the way packages like unmarked or ubms do Instead, covariates and their effect types are specified via a few dedicated function arguments. This non-standard approach may change in the future to instead support formula syntax. On the other hand it might be less confusing than the lme4 syntax for random effects. 


# Warning

A word of caution, please always check the model code and make sure you understand the code and agree with it. The workflow is meant to be convenient and does not require you to even look at the model code, but you should (there are many comments in the model code to make it easier). This workflow still requires a proper understanding of Bayesian modelling frameworks and the concepts behind multi-species occupancy models.

# Limitations

The workflow is still rather experimental, so please remain critical of the results and check carefully. If you encounter any problems, please let me know. 

There are currently a few limitations in the workflow: 

* priors can not be customized 
* models with categorical observation-level covariates cannot be compiled in Nimble and must be fit in JAGS instead
* nested random effects and random effects of site covariates are still experimental, and the plot_* methods don't work on these yet
* likewise, the output of `predict` may not be correct for these
* input checks are a bit limited and may not always lead to meaningful error messages. This will improve over time with user feedback.
* Nimble does not yet seem to have an advantage in processing speed. That might require further customization
* independent effects are only supported in continuous site covariates

Over time these will likely be worked on. 

# Parameter naming convention

The parameter names are assembled from standardized building blocks. The nomenclature is as follows:

```{r include=FALSE}
df_params = data.frame(Name = c("alpha", "beta", "0", "fixed", "indep", "ranef", "cont", "categ", "mean", "sigma", "tau"),
col2 = c("Submodel", "Submodel", "Intercept", "Effect type","Effect type", "Effect type", "Covariate type", "Covariate type",
         "Hyperparameter", "Hyperparameter", "Hyperparameter"),
col3 = c("detection submodel", "occupancy submodel", "denotes the intercepts (alpha0, beta0)",
         "fixed effects (constant across species)", "independent effects (separate and independent between species)", "random effects (of species and/or other categorical covariates)",
         "continuous covariates", "categorical covariates",
         "mean of random effect", "standard deviation of random effect", "precision of random effect (used internally, not returned)"))

names(df_params) <- c("Name", "Refers to", "Description")
```

```{r echo=FALSE}
library(knitr)
kable(df_params)
```



For example, a fixed intercept of occupancy (constant across species) is *beta0*, and a fixed intercept of detection probability is *alpha0*.

An occupancy probability intercept with a random effect of species is:

**beta0.mean** community mean of the occupancy probability intercept

**beta0.sigma** standard deviation of the community occupancy probability intercept.

**beta0[1]** occupancy probability intercept of species 1 (likewise for other species).

For effects of site covariates, the pattern is:

*submodel.effectType.covariateType.CovariateName.hyperparameter*

For example:

**beta.ranef.cont.habitat.mean** is the mean community effect of the continuous site covariate 'habitat' on occupancy probability.

**beta.ranef.cont.habitat[1]** is the effect of continuous site covariate 'habitat' on occupancy probability of species 1.

Site-occasion covariates are denoted by *.obs* after the submodel, e.g.:

**alpha.obs.fixed.cont.effort** is the fixed effect of the continuous observation-level covariate 'effort' on detection probability



# Quick example

Here is a quick example using the sample data that are included in camtrapR. The data set only contains five species at three fictional camera trap stations, and use made-up covariates (so the parameter estimates will be nonsense, ecologically). It is only a technical demonstration for how community models fit into the camtrapR workflow.

## Data preparation

First load the camera trap table and create a camera operation matrix:

```{r}
 data("camtraps")

 camop_no_problem <- cameraOperation(CTtable      = camtraps,
                                     stationCol   = "Station",
                                     setupCol     = "Setup_date",
                                     retrievalCol = "Retrieval_date",
                                     hasProblems  = FALSE,
                                     dateFormat   = "dmy"
 )
```

Now we load the record table and create a list of detection histories. Here we include all species, but you may want to subset the record table first. Note the argument `includeEffort = TRUE`, hence the output for each species will be a list (containing the detection history and effort matrix).

```{r}
 data("recordTableSample")

 # list of detection histories
 DetHist_list <- lapply(unique(recordTableSample$Species), FUN = function(x) {
   detectionHistory(
     recordTable         = recordTableSample,
     camOp                = camop_no_problem,
     stationCol           = "Station",
     speciesCol           = "Species",
     recordDateTimeCol    = "DateTimeOriginal",
     species              = x,     # this gets modifies by lapply
     occasionLength       = 7,
     day1                 = "station",
     datesAsOccasionNames = FALSE,
     includeEffort        = TRUE,
     scaleEffort          = FALSE,
     timeZone             = "Asia/Kuala_Lumpur"
   )}
 )

 # assign species names to the list items
 names(DetHist_list) <- unique(recordTableSample$Species)

 # note, DetHist_list is a list containing a list for each species
```

 
Get the detection history of each species and put into a new list (get rid of effort matrix).
```{r}
 ylist <- lapply(DetHist_list, FUN = function(x) x$detection_history)
```

Create some fake covariates (only for demonstration):
```{r}
 sitecovs <- camtraps[, c(1:3)]
 sitecovs$elevation <- c(300, 500, 600)
 sitecovs[, c(2:4)] <- scale(sitecovs[,-1])   # scale numeric covariates
 sitecovs$fact <- factor(c("A", "A", "B"))    # categorical covariate

```

Now we bundle the necessary data for `communityModel` in a list with 3 items: 

* ylist: the list of detection histories
* siteCovs: data frame with site covariates
* obsCovs: (named) list with observation level covariates. Requires at least the effort matrix.

```{r}
 data_list <- list(ylist    = ylist,
                   siteCovs = sitecovs,
                   obsCovs  = list(effort = DetHist_list[[1]]$effort))  # is identical for all species
```


Now `data_list` is a list containing the detection histories, site covariates and occasion level covariates. 

N.B.: It is always necessary to provide an effort matrix. This is to ensure that detection probability is 0 when there was no effort. This is achieved by creating a binary effort matrix based on the user-provided effort matrix. The binary effort matrix is 0 for all cells where effort = NA, and 1 for all cells with values (no matter what values). Thus, all occasions with effort = NA in the povided above effort matrix will have detection probability = 0.

Also note that this does **not** automatically include effort as a covariate on detection probability. To include effort as a covariate on detection probability, include "effort" in argument `detCovsObservation` (you can specify a fixed or random effect). 


## Fit model in JAGS

Now the interesting part. The function communityModel() creates a new class, "commOccu". It is an object that contains all relevant information for running a community occupancy model. Here we will create a JAGS model (the default). For a model in Nimble, see further below.


```{r}
# text file to save the model
 modelfile1 <- tempfile(fileext = ".txt")

 mod.jags <- communityModel(data_list,
                            occuCovs = list(fixed = "utm_y", ranef = "elevation"),
                            detCovsObservation = list(fixed = "effort"),
                            intercepts = list(det = "ranef", occu = "ranef"),
                            modelFile = modelfile1)
```

This call defined a model with a fixed effect of utm_y on occupancy probability of all species, and a species-specific (random) effect of elevation on occupancy probability. Furthermore, we specified effort as a covariate on detection probability (constant across species), and there are random effects of species on the intercepts of detection and occupancy probabilities. 


Note that throughout this vignette we use a temporary file to save the model text. In real examples you'd probably want to use a persistent file. 

One can also see the model code using (not shown here for brevity): 

```{r include = FALSE}
cat(mod.jags@modelText)
```



There is a very basic summary method for commOccu objects:

```{r}
 summary(mod.jags)
```

The model is fit with `fit()`.

```{r results="hide"}
 fit.jags <- fit(mod.jags,
                 n.iter = 1000,
                 n.burnin = 500,
                 chains = 3)
```

The output of the `fit()` method is an ` mcmc.list` from the coda package. 

Summarize posterior estimates:
```{r}
fit_summary <- summary(fit.jags)
```

Statistics of parameter estimates:
```{r}
# Note, colors may not render correctly in dark themes in RStudio.
DT::datatable(round(fit_summary$statistics, 3))
```



Quantiles of parameter estimates:
```{r}
DT::datatable(round(fit_summary$quantiles, 3))
```


Marginal effect plots (response curves) can be plotted with `plot_effects()`. Argument `submodel` defines whether the output is for the detection or occupancy part of the model:

```{r}
 plot_effects(mod.jags,
              fit.jags,
              submodel = "state")

 plot_effects(mod.jags,
              fit.jags,
              submodel = "det")
```

Likewise, we can plot effect sizes for easier comparison between species and for easily checking significance with `plot_coef()`:

```{r}
 plot_coef(mod.jags,
           fit.jags,
           submodel = "state",
           combine = T)

 plot_coef(mod.jags,
           fit.jags,
           submodel = "det")
```

There are further arguments for the significance levels, sorting species by parameter estimates, and for combining multiple plots.


## Models in Nimble

### Introduction

NIMBLE is a system for building and sharing analysis methods for statistical models, especially for hierarchical models and computationally-intensive methods. NIMBLE is built in R but compiles your models and algorithms using C++ for speed. 

(https://r-nimble.org/)

It allows you to run the same models as BUGS or JAGS, but can be much faster in some situations.

Using Nimble for community occupancy models requires the packages "nimble" and "nimbleEcology":

```{r message=FALSE}
library(nimble)
library(nimbleEcology)
```

### Compilation and Rtools

Using nimble only makes sense if one can compile the models (which runs them as fast C++ code). Compiling Nimble code requires Rtools.

You can obtain Rtools from: https://cran.r-project.org/bin/windows/Rtools/. 

It then needs to be put in PATH, see here for how to do it: 
https://cran.r-project.org/bin/windows/Rtools/#putting-rtools-on-the-path.

Depending on where you installed Rtools, you should see something like "C:/rtools40/usr/bin" somewhere in the output of the following line (for me it's usually the first or second entry).

```{r eval = FALSE}
Sys.getenv("PATH") 
```


### Fit models in Nimble

```{r include=FALSE}
require(nimble)
require(nimbleEcology)
```

We can fit the same model in Nimble using the exact same functions as for the JAGS model above. Only set `nimble = TRUE`.

```{r}
 modelfile2 <- tempfile(fileext = ".txt")

 mod.nimble <- communityModel(data_list,
                              occuCovs = list(fixed = "utm_x", ranef = "utm_y"),
                              detCovsObservation = list(fixed = "effort"),
                              intercepts = list(det = "ranef", occu = "ranef"),
                              modelFile = modelfile2,
                              nimble = TRUE)      # set nimble = TRUE
```

It is possible to fit uncompiled models, but it is usually extremely slow and should only be done for checking model structure and expected outputs, using very few iterations. 

```{r results="hide", message = FALSE}
 fit.nimble.uncomp <- fit(mod.nimble,
                          n.iter = 10,
                          chains = 1)

# the notes and the error message above are harmless
```


To fit a compiled model, set compile = TRUE:

```{r results="hide", message = FALSE}
 fit.nimble.comp <- fit(mod.nimble,
                        n.iter = 10000,
                        n.burnin = 5000,
                        chains = 3,
                        compile = TRUE, 
)
```

The output as an `mcmc.list`, just like for the JAGS model above, and can be worked with just the same:

```{r eval = FALSE}
 # parameter summary statistics (not shown)
 summary(fit.nimble.comp)
```

Response curves (= marginal effect plots):
```{r}
 plot_effects(mod.nimble,
              fit.nimble.comp,
              submodel = "state")

 plot_effects(mod.nimble,
              fit.nimble.comp,
              submodel = "det")
```

Effect size plots:
```{r}
 plot_coef(mod.nimble,
           fit.nimble.comp,
           submodel = "state",
           combine = TRUE)

 plot_coef(mod.nimble,
           fit.nimble.comp,
           submodel = "det")
```

Traceplots (not shown)
```{r eval = FALSE}
 plot(fit.nimble.comp)
```


The estimates and marginal effects are not very pretty, and the model would likely require more iterations to achieve smooth estimates.


# More complete example

The example above was very small and unrealistic. We can't provide a large camera trapping data set in camtrapR, but we can simulate one using the `simComm` function from the `AHMbook` package. Using a simulated data set also means we can compare model estimates to the "true" parameters (which were used to create the simulated data).

## Prepare data

First, install the AHMbook package if necessary:
```{r eval = FALSE}
install.packages("AHMbook")
```


```{r message=F}
library(AHMbook)
```


Simulate community with `simComm()`. Here we simulate a community with 20 species, 30 camera trap stations and 5 occasions. 

```{r}
set.seed(10)
com <- simComm(nspecies = 20, 
                nsites = 30,
                nreps = 5,
                mean.psi = 0.25,     # community mean of psi over all species in community (probability scale)  (0.25 = -1.1 on logit scale)
                sig.lpsi = 1,        # SD around intercept of logit(psi)
                mean.p = 0.25,       # community mean of detection probability over all species (0.25 = -1.1 on logit scale)
                sig.lp = 1,          # SD around intercept of logit(p)
                mu.beta.lpsi = 0.5,  # mean (community) effect of habitat on logit(psi)
                sig.beta.lpsi = 0.5, # SD around mean (community) effect of habitat on logit(psi)
                mu.beta.lp = -0.5,   # mean (community) effect of wind on logit(p)
                sig.beta.lp = 1)     # SD around mean (community) effect of wind on logit(p)
```


We need to wrangle the data a little to convert the data to input for `communityModel()`. This is only needed here because the data are generated by `AHMbook::simComm()`.

```{r}

# get continuous site covariate "habitat"
habitat <- com$habitat

# create (fake) categorical covariate (3 levels)
# setting "medium" as reference level
categ <- factor(ifelse(habitat < -0.5, "low", ifelse(habitat < 0.5, "medium", "high")), levels = c("medium", "low", "high"))

# get observation covariate
wind <- com$wind

# list of detection histories
ylist <- purrr::array_branch(com$y.all, 3)

# remove unobserved species  (we leave that to data augmentation)
ylist <- ylist[sapply(ylist, sum) >= 1]

# here, effort was constant at all stations and occasions. Effort is thus a matrix of all 1
effort <- matrix(1, nrow = nrow(ylist[[1]]), ncol =  ncol(ylist[[1]]))

# bundle data
input_AHM <- list(ylist = ylist, 
                  siteCovs = data.frame(habitat = habitat,
                                        categ   = categ),
                  obsCovs = list(effort = effort,
                                 wind = wind))
```




## JAGS Model

Here's a model in JAGS, with a species-specific effect of habitat on occupancy and wind on detection, and species-specific intercepts. 

```{r}
modelFile_jags <- tempfile(fileext = ".txt")

model1_jags <- communityModel(
  occuCovs = list(ranef = c("habitat")), 
  detCovsObservation = list(ranef = "wind"),
  intercepts = list(det = "ranef", occu = "ranef"),
  data_list = input_AHM,
  modelFile = modelFile_jags)
```


```{r results="hide"}
out_ahm_jags <- fit(model1_jags, 
                    n.iter = 5000, 
                    n.burnin = 2500,
                    thin = 5,
                    chains = 3,
                    quiet = T
)
```

Summary statistics of model parameters:
```{r}
DT::datatable(round(summary(out_ahm_jags)$statistics, 3))
```

Since we used simulated data we can compare model estimates with the truth. For example, the  true effect of habitat on occupancy was mean = 0.5 (SD = 0.5). See `beta.ranef.cont.habitat.mean` and `beta.ranef.cont.habitat.sigma` in the table above for estimates.

The mean effect of wind on detection probability was -0.5 (SD = 1). See `alpha.obs.ranef.cont.wind.mean` and `alpha.obs.ranef.cont.wind.sigma` in the table above for estimates. 

Bayesian p-values can be inspected to check for lack of fit (overall or by species). Lack of fit at significance level = 0.05 is indicated by Bayesian p-values below 0.025 or greater than 0.975. In the example above, the overall Bayesian p-value (Bpvalue) indicates no problems with lack of fit. Likewise, species-level Bayesian p-values (Bpvalue_species) indicate no lack of fit for any species. This is not surprising because the model uses simulated data.



Plot response curves (marginal effects)
```{r}
plot_resp_jags_occu <- plot_effects(model1_jags, 
                                    out_ahm_jags)
plot_resp_jags_occu


plot_resp_jags_det <- plot_effects(model1_jags, 
                                   out_ahm_jags,
                                   submodel = "det")
plot_resp_jags_det
```

Plot coefficient estimates:
```{r}
plot_eff_jags_occu <- plot_coef(model1_jags, 
                                out_ahm_jags)
plot_eff_jags_occu


plot_eff_jags_det <- plot_coef(model1_jags, 
                               out_ahm_jags,
                               submodel = "det")
plot_eff_jags_det
```


By default, species are sorted by effect size. Alternatively, you can have them sorted by species names. Set `ordered = FALSE`:

```{r}
plot_eff_jags_occu2 <- plot_coef(model1_jags, 
                                out_ahm_jags,
                                ordered = FALSE)
plot_eff_jags_occu2
```



## Nimble Model

Here's the same model in Nimble:

```{r}
modelFile_nimble <- tempfile(fileext = ".txt")

model1_nimble <- communityModel(
  occuCovs = list(ranef = c("habitat")),
  detCovsObservation = list(ranef = "wind"),
  intercepts = list(det = "ranef", occu = "ranef"),
  data_list = input_AHM,
  modelFile = modelFile_nimble,
  nimble = TRUE)
```

We use some more iterations, since these Nimble models tend to require more iterations than equivalent JAGS models to achieve good estimates (numbers are still too low for publication quality though).

```{r results="hide"}
# compiled model run
out_ahm_nimble2 <- fit(model1_nimble, 
                       n.iter = 5000,
                       n.burnin = 2500,
                       thin = 5,
                       chains = 3,
                       compile = TRUE,
                       quiet = T
)


DT::datatable(round(summary(out_ahm_nimble2)$statistics, 3))
```



Plot responses (marginal effects):
```{r}
plot_resp_nimble_occu <- plot_effects(model1_nimble, 
                                      out_ahm_nimble2)
plot_resp_nimble_occu


plot_resp_nimble_det <- plot_effects(model1_nimble, 
                                     out_ahm_nimble2,
                                     submodel = "det")
plot_resp_nimble_det
```


Plot coefficient estimates:
```{r}
plot_eff_nimble_occu <- plot_coef(model1_nimble, 
                                  out_ahm_nimble2)
plot_eff_nimble_occu


plot_eff_nimble_det <- plot_coef(model1_nimble, 
                                 out_ahm_nimble2,
                                 submodel = "det")
plot_eff_nimble_det
```




## Missing values in detection histories


The examples so far did not have any missing data in the detection histories. Real-world data commonly have missing data though, e.g. due to camera malfunction or specific study designs. In single-species occupancy models (e.g. in unmarked or ubms) this is handled automatically, but requires a little more attention in these multi-species models (at least when fitting with Nimble). Let's modify the above data set and introduce some NAs in the detection history and the effort matrix:

```{r}
# introduce a few missing values in detection history of all species
index_na <-  sample(1:length(ylist[[1]]), 10) #
ylist_with_na <- lapply(ylist, FUN = function(x) {x[index_na] <- NA; x})


# set the cells with NA in detection history to NA in effort too
effort_with_na <- effort
effort_with_na[index_na] <- NA

# bundle model input
input_AHM_with_NA <- list(ylist = ylist_with_na, 
                          siteCovs = data.frame(habitat = habitat,
                                                categ   = categ),
                          obsCovs = list(effort = effort_with_na,
                                         wind = wind))

```

And fit models in JAGS and Nimble:



```{r}
modelFile_jags_na <- tempfile(fileext = ".txt")

model1_jags_na <- communityModel(
  occuCovs = list(ranef = c("habitat")), 
  detCovsObservation = list(ranef = "wind"),
  intercepts = list(det = "ranef", occu = "ranef"),
  data_list = input_AHM_with_NA,
  modelFile = modelFile_jags_na)
```


```{r results="hide"}
out_ahm_jags_na <- fit(model1_jags_na, 
                    n.iter = 5000, 
                    n.burnin = 2500,
                    thin = 5,
                    chains = 3,
                    quiet = T
)
```

Summary statistics of model parameters:
```{r}
DT::datatable(round(summary(out_ahm_jags_na)$statistics, 3))
```


As can be seen, the JAGS model handles NAs well and parameter estimates are very similar to the model without missing data above.


Nimble models can technically also be fit with NAs present, but there will be numerous warnings and residuals as well as Bayesian p-values cannot be computed. 


```{r}
modelFile_nimble_na <- tempfile(fileext = ".txt")

model1_nimble_na <- communityModel(
  occuCovs = list(ranef = c("habitat")), 
  detCovsObservation = list(ranef = "wind"),
  intercepts = list(det = "ranef", occu = "ranef"),
  data_list = input_AHM_with_NA,
  modelFile = modelFile_nimble_na,
  nimble = T)
```

When fitting the model there will be numerous warnings about values of data nodes y[,,] and determinisitc nodes res[,], R2[] and R3 being NA (not shown here).

```{r results="hide"}
out_ahm_nimble_na <- fit(model1_nimble_na, 
                    n.iter = 5000, 
                    n.burnin = 2500,
                    thin = 5,
                    chains = 3,
                    quiet = T
)
```

Parameter summaries cannot be computed and will return an error (not shown here).

```{r eval = FALSE}
DT::datatable(round(summary(out_ahm_nimble2)$statistics, 3))
```




To alleviate this, it is necessary (for Nimble models) to convert NAs in the detection history to 0, e.g. with:

```{r}
# replace NAs with 0 in the ylist component of input_AHM (for all species at once)
input_AHM_with_NA$ylist <- lapply(input_AHM_with_NA$ylist, FUN = function(x) {
  x[is.na(x)] <- 0
  x
})
```

After converting NAs to 0, Nimble models can be run without warnings and summaries can be calculated.


To prevent the additional 0s from affecting the estimation of detection probabilities, information about occasions without effort is provided via the mandatory argument `effortCov` in the `communityModel` function. Use the `$effort` part of the output of `detectionHistory()` to provide the necessary information, and of course ensure that `detectionHistory` is run with `includeEffort = T`. All occasions with NA in the effort matrix will have their detection probabilities fixed at 0. This ensures that those occasions do not affect the model fit. Be aware that this does not include effort as a covariate on detection. Including effort as a covariate on detection would need to be done via `detCovsObservation`.




# Further possibilies


This section demonstrates additional possibilities. The models here are (mostly) fit in JAGS, but can also be fit with Nimble. 

## Fixed effects

One can define fixed effects of covariates if the responses are thought to be constant across all species. This might make sense for the effect of sampling effort in camera trapping studies. 




## Priors

It is not yet possible to customize priors. The current defaults are: 

* dnorm(0, 0.05) : random effect means
* dgamma(0.1, 0.1): random effect precision (tau)

Future versions may allow more flexibility. Please contact me if this is relevant for you. In the meantime feel free to adjust the model code in the txt file as needed. 


## Data augmentation

`communityModel` has an argument `augmentation`, which can implement fully open data augmentation or data augmentation up to a known maximum number of species.


We know there are 20 species in the simulated community example. We can inform the model that the community is known to consist of 20 species via: `augmentation = c(maxknown = 20)`:

```{r message=FALSE, warning=FALSE, results="hide"}
modelFile_jags_aug1 <- tempfile(fileext = ".txt")

model1_jags_aug1 <- communityModel(
  occuCovs           = list(ranef = c("habitat")), 
  detCovsObservation = list(ranef = "wind"),
  intercepts         = list(det = "ranef", occu = "ranef"),
  data_list          = input_AHM,
  augmentation       = c(maxknown = 20),
  modelFile          = modelFile_jags_aug1)

# short model run for demonstration
out_ahm_jags_aug1 <- fit(model1_jags_aug1, 
                         n.iter = 500, 
                         n.burnin = 250,
                         thin = 5,
                         chains = 3,
                         quiet = T
)

```

Here is another example with fully open data augmentation (metacommunity size is unknown). The model will estimate the probability for each species to be part of the metacommunity. Fully open data augmentation is specified with `augmentation = c(full = 30)` (for a maximum potential community size of 30 species in this example).

```{r message=FALSE, warning=FALSE, results="hide"}
modelFile_jags_aug2 <- tempfile(fileext = ".txt")

model1_jags_aug2 <- communityModel(
  occuCovs = list(ranef = c("habitat")), 
  detCovsObservation = list(ranef = "wind"),
  intercepts = list(det = "ranef", occu = "ranef"),
  data_list = input_AHM,
  augmentation = c(full = 30),
  modelFile = modelFile_jags_aug2)

# short model run for demonstration
out_ahm_jags_aug2 <- fit(model1_jags_aug2, 
                         n.iter = 500, 
                         n.burnin = 250,
                         thin = 5,
                         chains = 3,
                         quiet = T
)
```

See parameters "omega" and "w[1]" to "w[30]" in the model output:

```{r}
DT::datatable(round(summary(out_ahm_jags_aug2)$statistics, 3))
```

Higher numbers of species in data augmentation increase model run time.



## Categorical covariates

### Site covariates

Site covariates will be interpreted as categorical if they are factors in the input data frame. If a random effect of a categorical covariate is defined, there will be independent species-level random effects within each factor level of the categorical covariate. In other words, each factor level will have its own and independent random effect of species.

Here is an example with a categorical site covariate "categ" on occupancy:

```{r message=FALSE, warning=FALSE, results="hide"}
modelFile_jags_categ1 <- tempfile(fileext = ".txt")

model_jags_categ1 <- communityModel(
  occuCovs = list(ranef = c("categ")),
  detCovsObservation = list(ranef = "wind"),
  intercepts = list(det = "ranef", occu = "ranef"),
  data_list = input_AHM,
  modelFile = modelFile_jags_categ1)

# short model run for demonstration
out_ahm_jags_categ1 <- fit(model_jags_categ1, 
                         n.iter = 500, 
                         n.burnin = 250,
                         thin = 5,
                         chains = 3,
                         quiet = T
)
```

Plot the results:
```{r}
plot_effects(object = model_jags_categ1,
             mcmc.list = out_ahm_jags_categ1)

plot_coef(object = model_jags_categ1,
          mcmc.list = out_ahm_jags_categ1)
```


In the table below, see the arguments `beta.ranef.categ.categ`. The species effects have two indices: [species, factorLevel]. Accordingly, there are three estimates for `mean` and `SD`, respectively. All estimates for the first factor level are 0, since the intercept refers to the first factor level (i.e. reference level, which we defined as "medium" above). 

```{r}
DT::datatable(round(summary(out_ahm_jags_categ1)$statistics, 3))
```


### Observation-level covariates

Currently categorical observation-level covariates are only fully supported in JAGS, not Nimble. Observation-level covariates are matrices and thus can't be factors. Thus they need to be defined as character matrices.

```{r}
# Create example categorical observation covariate
input_AHM$obsCovs$wind_categ <- ifelse(input_AHM$obsCovs$wind > 0, "windy", "calm")

# result is a character matrix:
str(input_AHM$obsCovs$wind_categ)
```


Model example:

```{r message=FALSE, warning=FALSE, results="hide"}
modelFile_jags_categ2 <- tempfile(fileext = ".txt")

model_jags_categ2 <- communityModel(
  occuCovs = list(fixed = c("habitat")), 
  detCovsObservation = list(ranef = c("wind_categ")),     # "wind_categ" now
  intercepts = list(det = "ranef", occu = "ranef"),
  data_list = input_AHM,
  modelFile = modelFile_jags_categ2)

out_ahm_jags_categ2 <- fit(model_jags_categ2, 
                         n.iter = 500, 
                         n.burnin = 250,
                         thin = 5,
                         chains = 3,
                         quiet = T,
                         compile = FALSE
)
```

Model estimates. As above, the estimates for the first factor level are 0. The relevant parameters here are called `alpha.obs.ranef.categ.wind_categ`.

```{r}
DT::datatable(round(summary(out_ahm_jags_categ2)$statistics, 3))
```

Plot the results:
```{r}
plot_effects(object = model_jags_categ2, 
             mcmc.list = out_ahm_jags_categ2,
             submodel = "det")

plot_coef(object = model_jags_categ2, 
          mcmc.list = out_ahm_jags_categ2,
          submodel = "det")
```


## Random effects other than species

By default random effects are by species. Alternatively, you can specify random effects of a categorical site covariate2 on continuous covariate1 using the pattern:

occuCovs(ranef = c("covariate1|covariate2"))

The same syntax can be used in 

detCovs(ranef = c("covariate1|covariate2"))

and 

detCovs(ranef = c("covariate1|covariate2"))


Here is an example, where the effect of "habitat" differs between levels of "categ".

```{r message=FALSE, warning=FALSE, results="hide"}
modelFile_jags_ranef <- tempfile(fileext = ".txt")

model1_jags_ranef <- communityModel(
  occuCovs = list(ranef = c("habitat|categ")), 
  detCovsObservation = list(ranef = "wind"),
  intercepts = list(det = "ranef", occu = "ranef"),
  data_list = input_AHM,
  modelFile = modelFile_jags_ranef)

# short model run for demonstration
out_ahm_jags_ranef <- fit(model1_jags_ranef, 
                         n.iter = 500, 
                         n.burnin = 250,
                         thin = 5,
                         chains = 3,
                         quiet = T
)
```


Search for the term "habitat_categ" in the table below. There are 2 estimates (for stations with "A" and "B"), plus the mean and sigma of the random effect (this is only for demonstration, 2 factor levels is of course not enough for applying random effects).

```{r}
DT::datatable(round(summary(out_ahm_jags_ranef)$statistics, 3))
```

Currently random effects other than species can not be plotted with `plot_effects` and `plot_coef`.


## Nested random effects

Consider a numeric covariate1 and categorical covariate2. 

Use the keyword "+Species" to specify a species-specific random effect within each factor level of covariate2:

occuCovs(ranef = c("covariate1|covariate2+Species"))


Here is an example, with independent random effect of "categ" on "habitat" for each species:

```{r message=FALSE, warning=FALSE, results="hide"}
modelFile_jags_nested <- tempfile(fileext = ".txt")

model1_jags_nested <- communityModel(
  occuCovs = list(ranef = c("habitat|categ+Species")), 
  detCovsObservation = list(ranef = "wind"),
  intercepts = list(det = "ranef", occu = "ranef"),
  data_list = input_AHM,
  modelFile = modelFile_jags_nested)

# short model run for demonstration
out_ahm_jags_nested <- fit(model1_jags_nested, 
                         n.iter = 500, 
                         n.burnin = 250,
                         thin = 5,
                         chains = 3,
                         quiet = T
)
```

Search for the term "habitat_categ_Species" in the table below. Depending on the number of species and factor levels The number of parameter estimates is very high when using nested random effects.

```{r}
DT::datatable(round(summary(out_ahm_jags_nested)$statistics, 3))
```

Currently nested random effects can not be plotted with `plot_effects` and `plot_coef`.


##  Species and site random effect on detection

Species and site random effect on detection probability can be helpful if Bayesian p-values indicate lack of fit (overall and / or for individual species). Such an effect can be added via argument `speciesSiteRandomEffect`. Setting it to TRUE adds a random effect "ran" to detection probability in the form:

logit.p[i,j,k] <- alpha0[i] + ... + **ran[i, j]**

where i,j are species and station and occasion indices. `ran` is defined as: 

ran[i,j] ~ dnorm(0, tau.ran)

with `tau.ran` being the precision of the normal distribution (precision = 1 / standard deviation).

Site is defined as the sampling location (e.g. camera trap station in this context). 

Below is an example model:

```{r message=FALSE, warning=FALSE, results="hide"}
modelFile_jags_species_station_ran <- tempfile(fileext = ".txt")

model1_jags_species_station_ran <- communityModel(
  occuCovs = list(ranef = c("habitat")), 
  detCovsObservation = list(ranef = "wind"),
  intercepts = list(det = "ranef", occu = "ranef"),
  speciesSiteRandomEffect = list(det = TRUE),
  data_list = input_AHM,
  modelFile = modelFile_jags_species_station_ran)

# short model run for demonstration
out_ahm_jags_species_station_ran <- fit(model1_jags_species_station_ran, 
                                        n.iter = 500, 
                                        n.burnin = 250,
                                        thin = 5,
                                        chains = 3,
                                        quiet = T
)
```


The model returns the standard deviation of this random effect as `alpha.speciessite.ranef.sigma`, which can be found in the table below.

```{r}
DT::datatable(round(summary(out_ahm_jags_species_station_ran)$statistics, 3))
```



## Quadratic covariate effects

The easiest way to include quadratic effects is by squaring the covariate and including it as a new covariate. The plot_* and predict methods will be able to identify the quadratic term via a required keyword (the suffix "_squared" by default). 

Covariates should be scaled to prior to squaring ("habitat" in this examples is already scaled). 

Create quadratic covariate:

```{r}
input_AHM$siteCovs$habitat_squared <- input_AHM$siteCovs$habitat ^2
```



Create and fit model:

```{r message=FALSE, warning=FALSE, results="hide"}
modelFile_jags_quadratic <- tempfile(fileext = ".txt")


model1_jags_quadratic <- communityModel(
  occuCovs = list(ranef = c("habitat", "habitat_squared")), 
  detCovsObservation = list(ranef = "wind"),
  intercepts = list(det = "ranef", occu = "ranef"),
  data_list = input_AHM,
  modelFile = modelFile_jags_quadratic)

# short model run for demonstration
out_ahm_jags_quadratic<- fit(model1_jags_quadratic, 
                         n.iter = 5000, 
                         n.burnin = 2500,
                         thin = 5,
                         chains = 3,
                         quiet = T
)

```


Thanks to to keyword "_squared", `plot_effects` knows that "habitat" and "habitat_squared" are the same covariate and will combine the effects of "habitat" and "habitat_squared" in response curves.

```{r}
plot_effects(model1_jags_quadratic, 
             out_ahm_jags_quadratic)
```

The simulated data have no quadratic relationship with covariates, hence the quadratic effects are rather weak in this example.


## WAIC

Nimble models can return WAIC. Set argument `fit(..., WAIC = TRUE)`.


```{r message=FALSE, warning=FALSE, results="hide"}
out_ahm_nimble3 <- fit(model1_nimble, 
                       n.iter = 500,
                       n.burnin = 250,
                       thin = 5,
                       chains = 3,
                       compile = TRUE,
                       quiet = F, 
                       WAIC = TRUE
)
```

The message about "individual pWAIC values that are greater than 0.4" in the example is likely due to the short model run. 

If `WAIC = TRUE`, the output will be a list with 2 elements. The first ("samples") is the familiar mcmc.list, the second ("WAIC") is a waicList. 


mcmc.list is accessible with $samples:
```{r eval = FALSE}
# not printed here
summary(out_ahm_nimble3$samples)$statistics

```

WAIC:
```{r}
out_ahm_nimble3$WAIC
```

## Species richness estimates for categorical covariates

This is only possible in JAGS models. Argument "richnessCategories" can be used to calculate separate species richness estimates for different levels of categorical site covariates. If it is not defined, there will only be a global species richness estimate. 

```{r message=FALSE, warning=FALSE, results="hide"}
modelFile_jags_richness <- tempfile(fileext = ".txt")

model1_jags_richness <- communityModel(
  occuCovs = list(ranef = c("habitat")), 
  detCovsObservation = list(ranef = "wind"),
  intercepts = list(det = "ranef", occu = "ranef"),
  data_list = input_AHM,
  richnessCategories = "categ",
  modelFile = modelFile_jags_richness)

# short model run for demonstration
out_ahm_jags_rich <- fit(model1_jags_richness, 
                         n.iter = 500, 
                         n.burnin = 250,
                         thin = 5,
                         chains = 3,
                         quiet = T
)
```

Now search for "Nspecies" in the table below. You will see 3 entries. "Nspecies" is overall, Nspecies_by_category[1] and ...[2] are for the stations in category "A" and "B", respectively.

```{r}
DT::datatable(round(summary(out_ahm_jags_rich)$statistics, 3))
```


## Spatial predictions

You can create spatial predictions based on the occupancy models created with `communityModel`, their model fits and covariate raster stacks.

This requires the raster package.

```{r message=FALSE, warning=FALSE, results="hide"}
  library(raster)
```

In this example we will use a model that has both a continuous and a categorical covariate. 

```{r message=FALSE, warning=FALSE, results="hide"}
modelFile_jags_categ3 <- tempfile(fileext = ".txt")

model_jags_categ3 <- communityModel(
  occuCovs = list(ranef = c("habitat", 
                            "categ")),
  detCovsObservation = list(ranef = "wind"),
  intercepts = list(det = "ranef", occu = "ranef"),
  data_list = input_AHM,
  modelFile = modelFile_jags_categ3)

# short model run for demonstration
out_ahm_jags_categ3 <- fit(model_jags_categ3, 
                         n.iter = 500, 
                         n.burnin = 250,
                         thin = 5,
                         chains = 3,
                         quiet = T
)
```



Create a habitat raster. We'll use the volcano raster for demonstration. The coordinates are not geographic though since this is only for demonstration. 
```{r}
data("volcano")
r_volcano <- scale(raster(volcano))
```

create a categorical raster. Since it is not possible to have categorical raster (with data type "factor"), the raster must consist of integer numbers that refer to the factor levels (as defined in the model input). 

```{r}
levels(input_AHM$siteCovs$categ)    # show the order of factor levels, first one is reference

raster_categ <- raster(x = matrix(rep(c(1,2, 3), each = length(r_volcano) / 3), 
                                  ncol = ncol(r_volcano),
                                  nrow = nrow(r_volcano)))
```



```{r}
# add raster to list
  stack_prediction <- stack(list(habitat = r_volcano,
                                 categ = raster_categ))
plot(stack_prediction)
# raster categ, from west to east: 1 = medium, 2 = low, 3 = high
```

Species occupancy maps:
```{r}
# species occupancy estimates
  predictions_psi <- predict(object    = model_jags_categ3, 
                             mcmc.list = out_ahm_jags_categ3,
                             x         = stack_prediction,
                             type      = "psi",
                             draws     = 1000)
  

  plot(predictions_psi$mean, zlim = c(0,1), 
       col = hcl.colors(100), 
       maxnl = 9)   # plotting only the first 9 species for space reasons

```

Species richness maps:
```{r}
# species richness estimates
  predictions_rich <- predict(object   = model_jags_categ3, 
                             mcmc.list = out_ahm_jags_categ3,
                             x         = stack_prediction,
                             type      = "richness")
  
  plot(predictions_rich, col = hcl.colors(100))
  # mean = mean species richness estimate
  # sd = standard deviation of richness estimate
```

In these examples we did not return confidence intervals. Doing so would be easy by setting `intervals =  "confidence"`.

Computation can take long on larger rasters and can require lots of RAM. Check RAM usage during computations. 



## Percentage of area occupied (by species)


The `predict` function can be used to calculate Percentage of Area Occupied (PAO) for all species, optionally for a given area of interest (AOI). 

For demonstration, let's create a AOI as a SpatialPolygonsDataFrame. Normally you'd just load a shapefile or other spatial vector data set.

```{r}
Sr1 = Polygon(cbind(c(0.2,0.2, 0.6,0.6, 0.2),c(0.4,0.7, 0.8,0.4,0.4)))
Srs1 = Polygons(list(Sr1), "1")
SpP = SpatialPolygons(list(Srs1))
aoi = SpatialPolygonsDataFrame(SpP, data = data.frame(name = "My AOI"))
```

```{r}
plot(r_volcano)
plot(aoi, add = T)
```


To use the SpatialPolygonsDataFrame as an AOI, we need to rasterize it. PAO will refer to all cells in the AOI raster that are not NA. 

```{r}
r_aoi <- rasterize(aoi, r_volcano)
plot(r_aoi)
```


Now the prediction of PAO:

```{r}
  predictions_pao <- predict(object    = model_jags_categ3, 
                             mcmc.list = out_ahm_jags_categ3,
                             x         = stack_prediction,
                             type      = "pao", 
                             aoi       = r_aoi)
  
```
Output is a list with several components: 

$pao_summary is a summary table with quantiles of predicted PAO for all species. 

```{r}
predictions_pao$pao_summary
```


$pao_matrix contains the PAO estimates for all species from all posterior draws (not shown here)
```{r eval = FALSE}
predictions_pao$pao_matrix
```

$pao_df is similar to $pao_matrix, but in a data frame in long format, ready for use in ggplot2.

```{r}
  ggplot2::ggplot(predictions_pao$pao_df, aes(x = Species , y = PAO)) +
  geom_boxplot(outlier.shape = NA) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

$aoi is a RasterLayer showing the AOI (now with cells removed that are NA in the prediction rasters)

```{r}
plot(predictions_pao$aoi)
```



## bayesplot

We can also use the powerful bayesplot package for visualizing model estimates. One downside is that it won't automatically insert the species names.

```{r message=FALSE}
library(bayesplot)
```

Here is an example for density plots showing the species-level effects of habitat on occupancy:
```{r}
mcmc_areas(out_ahm_nimble2, regex_pars = "beta.ranef.cont.habitat")
```

bayesplot has many other visualization options beyond this example. See the respective documentation, e.g. https://mc-stan.org/bayesplot/.


## Model diagnostics

Output of `fit()` is a coda::mcmc.list, so `plot()` provides traceplots (not shown here for space reasons):

```{r eval = FALSE}
plot(out_ahm_nimble2)
```


The Gelman-Rubin convergence statistic (potential scale reduction factor) can be calculated with `gelman.diag()` from `coda`:

```{r}
gd <- gelman.diag(out_ahm_nimble2,  multivariate = FALSE)
gd
```

One can also use `gelman.plot` to create Gelman-Rubin-Brooks plots (evolution of Gelman-Rubin statistic over iterations):

```{r eval = FALSE}
# not shown here due to space reasons
gelman.plot(out_ahm_nimble2,  multivariate = FALSE)
```


## Royle-Nichols model


Instead of a standard occupancy model one can fit the occupancy model of Royle and Nichols (2003), which relates probability of detection of the species to the number of individuals available for detection at each site (instead of their occupancy status alone). Probability of occupancy is a derived parameter: the probability that at least one individual is available for detection at the site. It is achieve by setting the parameter "model" to "RN":


```{r results="hide"}
modelFile_jags_RN <- tempfile(fileext = ".txt")

model1_jags_RN <- communityModel(
  model = "RN",
  occuCovs = list(ranef = c("habitat")),
  detCovsObservation = list(ranef = "wind"),
  intercepts = list(det = "ranef", occu = "ranef"),
  data_list = input_AHM,
  modelFile = modelFile_jags_RN)


out_ahm_jags_RN <- fit(model1_jags_RN, 
                    n.iter = 5000, 
                    n.burnin = 2500,
                    thin = 5,
                    chains = 3,
                    quiet = T
)
```

The models can be processed as shown before, e.g.: 

Summary statistics of model parameters:
```{r}
DT::datatable(round(summary(out_ahm_jags_RN)$statistics, 3))
```

Response curves (marginal effect plots):

```{r}
plot_effects(model1_jags_RN, 
             out_ahm_jags_RN)



plot_effects(model1_jags_RN, 
             out_ahm_jags_RN,
             submodel = "det")
```

Coefficient plots:

```{r}
plot_coef(model1_jags_RN,
          out_ahm_jags_RN,
          ordered = FALSE)

plot_coef(model1_jags_RN,
          out_ahm_jags_RN,
          ordered = FALSE,
          submodel = "det")
```


Predictions work as before, but a Royle-Nichols model allows for returning expected species abundance (lambda) via `r paste('type = "abundance"')` and `r paste('type = "lambda_array"')`. Occupancy predictions internally convert abundance to occupancy.

Occupancy predictions (`r paste('type = "psi"')`)
```{r}
predictions_psi_RN <- predict(object    = model1_jags_RN, 
                             mcmc.list = out_ahm_jags_RN,
                             x         = stack_prediction,
                             type      = "psi",
                             draws     = 200)
plot(predictions_psi_RN$mean, 
     col = hcl.colors(100),
       maxnl = 9)  # first 9 species only

```


Abundance predictions (`r paste('type = "abundance"')`):
```{r}

predictions_abundance_RN <- predict(object    = model1_jags_RN, 
                             mcmc.list = out_ahm_jags_RN,
                             x         = stack_prediction,
                             type      = "abundance",
                             draws     = 200)
plot(predictions_abundance_RN$mean, 
     col = hcl.colors(100),
     maxnl = 9)   # first 9 species only
```

Richness predictions (`r paste('type = "richness"')`)
```{r}
  predictions_richness_RN <- predict(object    = model1_jags_RN, 
                             mcmc.list = out_ahm_jags_RN,
                             x         = stack_prediction,
                             type      = "richness",
                             draws     = 200)
plot(predictions_richness_RN$mean, col = hcl.colors(100))
```

PAO predictions (`r paste('type = "pao"')`):
```{r}
  predictions_pao_RN <- predict(object    = model1_jags_RN, 
                             mcmc.list = out_ahm_jags_RN,
                             x         = stack_prediction,
                             type      = "pao",
                             draws     = 200)
DT::datatable(predictions_pao_RN$pao_summary)

```


## Single-species occupancy models

Incidentally, the workflow above can be used for single-species models too. The code will be less streamlined and possibly slower than normal code for single-species models (due to the species loop which is unnecessary for single-species models), but it is possible. Simply pass a single detection history in the data_list$ylist of the input to `communityModel`. 

Take care to only define fixed effects for covariates and the intercepts, not random effects of species. It is possible however to specify random effects of categorical site covariates on continuous site covariates as in the example below. 


In this example we use species 1 from the community created with `AHMbook::simComm`. 

```{r}
input_AHM_sp1 <- list(ylist = ylist[1],    # ylist[1] is still a list, with 1 element
                      siteCovs = input_AHM$siteCovs,
                      obsCovs = input_AHM$obsCovs)
```

Create model:
```{r message=FALSE, warning=FALSE, results="hide"}
modelFile_jags_sp1 <- tempfile(fileext = ".txt")

model_sp1_jags_ranef <- communityModel(
  occuCovs = list(ranef = c("habitat|categ")),    # response to habitat differs between categ via random effect
  detCovsObservation = list(fixed = "wind"),
  intercepts = list(det = "fixed", occu = "fixed"),
  data_list = input_AHM_sp1,
  modelFile = modelFile_jags_sp1)
```

Fit model:
```{r message=FALSE, warning=FALSE, results="hide"}
fit_jags_sp1 <- fit(model_sp1_jags_ranef, n.iter = 1000, n.burnin = 500, thin = 5)
```

Print summary statistics:
```{r}
DT::datatable(round(summary(fit_jags_sp1)$statistics, 3))
```

The `plot_effects()` and `plot_coef()` functions currently don't work for this case, since single-species models are mostly a side-effect of the intended community occupancy workflow and not the main goal. There are other great options for Bayesian single-species occupancy models, e.g. in the packages ubms or wiqid, or unmarked for a frequentist implementation.
